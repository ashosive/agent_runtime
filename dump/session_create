use uuid::Uuid;
use chrono::Utc;
use serde::{Serialize, Deserialize};
use std::sync::Arc;
use once_cell::sync::Lazy;
use dashmap::DashMap;

use crate::session_creation::types::{
    Session,
    SessionState,
    SessionLimits,
    SessionContextSeed,
    SessionAccounting,
};

#[derive(Serialize, Deserialize, Debug)]
pub struct CreateSessionRequest {
    pub system_prompt: Option<String>,
    pub user_prompt_snapshot: Option<String>,
    pub max_tokens: Option<u32>,
    pub max_duration_ms: Option<u64>,
    pub max_context_bytes: Option<u32>,
}

#[derive(Serialize, Deserialize, Debug)]
pub struct SessionReceipt {
    pub session_id: Uuid,
    pub created_at: chrono::DateTime<Utc>,
}

pub fn create_session(request: CreateSessionRequest) -> (Arc<Session>, SessionReceipt) {
    let limits = SessionLimits {
        max_tokens: request.max_tokens.unwrap_or(2048),
        max_duration_ms: request.max_duration_ms.unwrap_or(60_000),
        max_context_bytes: request.max_context_bytes.unwrap_or(256 * 1024),
    };

    let context_seed = SessionContextSeed {
        system_prompt: request.system_prompt.unwrap_or_else(|| "You are an AI assistant.".to_string()),
        user_prompt_snapshot: request.user_prompt_snapshot,
    };

    let now = Utc::now();

    let session = Arc::new(Session {
        id: Uuid::new_v4(),
        state: SessionState::Active,
        limits,
        created_at: now,
        updated_at: now,
        context_seed,
        accounting: SessionAccounting {
            prompt_tokens: 0,
            output_tokens: 0,
            requests: 0,
        },
    });

    let receipt = SessionReceipt {
        session_id: session.id,
        created_at: now,
    };

    (session, receipt)
}

static SESSION_RAM: Lazy<DashMap<Uuid, Arc<Session>>> = Lazy::new(DashMap::new);

pub fn save_session_to_ram(session: &Arc<Session>) {
    SESSION_RAM.insert(session.id, Arc::clone(session));
}

pub fn get_session_from_ram(id: &Uuid) -> Option<Arc<Session>> {
    SESSION_RAM.get(id).map(|e| Arc::clone(e.value()))
}

pub fn remove_session_from_ram(id: &Uuid) -> Option<Arc<Session>> {
    SESSION_RAM.remove(id).map(|(_, v)| v)
}

pub fn list_session_ids() -> Vec<Uuid> {
    SESSION_RAM.iter().map(|e| *e.key()).collect()
}
